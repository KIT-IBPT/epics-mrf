/*
 * Copyright 2015-2025 aquenos GmbH.
 * Copyright 2015-2025 Karlsruhe Institute of Technology.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this program.  If not, see
 * <http://www.gnu.org/licenses/>.
 *
 * This software has been developed by aquenos GmbH on behalf of the
 * Karlsruhe Institute of Technology's Institute for Beam Physics and
 * Technology.
 *
 * This software contains code originally developed by aquenos GmbH for
 * the s7nodave EPICS device support. aquenos GmbH has relicensed the
 * affected poritions of code from the s7nodave EPICS device support
 * (originally licensed under the terms of the GNU GPL) under the terms
 * of the GNU LGPL version 3 or newer.
 */

#include <chrono>
#include <cmath>
#include <cstdio>
#include <cstring>
#include <functional>
#include <stdexcept>

#include <epicsExport.h>
#include <epicsVersion.h>
#include <iocsh.h>

#include <MrfConsistentAsynchronousMemoryAccess.h>
#include <MrfDeviceRegistry.h>
#include <MrfUdpIpMemoryAccess.h>
#include <mrfEpicsError.h>

#if EPICS_VERSION_INT >= VERSION_INT(7,0,3,1)
#  define MRF_IOC_SET_ERROR(func) iocshSetError(func)
#else
#  define MRF_IOC_SET_ERROR(func) (func)
#endif


using namespace anka::mrf;
using namespace anka::mrf::epics;

namespace {

/**
 * Preheats the cache for a VME-EVG-230. This helps reduce the initialization
 * time of the IOC because preheating can happen for several devices in
 * parallel, while the record initialization itself is not parallelized and
 * would that have to wait for each I/O request to finish before it could
 * continue. There is no error checking here. If there is an error, the memory
 * location simply won't be cached, and the respective error will be presented
 * to the user when the second I/O attempt that is made after checking the cache
 * fails (unless the underlying problem has been resolved by then).
 */
void preheatCacheVmeEvg230(std::shared_ptr<MrfMemoryCache> cache) {
  // This code has been generated by preheat-cache-codegen.py using the output
  // of mrfDumpCache(...). If output records are added to the record file, this
  // code section needs to be updated.
  for (std::uint32_t address = 0x00000400; address < 0x00000408; address += 2) {
      cache->tryCacheUInt16(address);
  }
  for (std::uint32_t address = 0x00000440; address < 0x00000448; address += 2) {
      cache->tryCacheUInt16(address);
  }
  cache->tryCacheUInt32(0x00000004);
  for (std::uint32_t address = 0x0000000c; address < 0x0000001c; address += 4) {
      cache->tryCacheUInt32(address);
  }
  for (std::uint32_t address = 0x00000020; address < 0x0000002c; address += 4) {
      cache->tryCacheUInt32(address);
  }
  cache->tryCacheUInt32(0x0000004c);
  cache->tryCacheUInt32(0x00000050);
  cache->tryCacheUInt32(0x00000060);
  cache->tryCacheUInt32(0x00000070);
  cache->tryCacheUInt32(0x00000074);
  cache->tryCacheUInt32(0x00000080);
  for (std::uint32_t address = 0x00000100; address < 0x00000120; address += 4) {
      cache->tryCacheUInt32(address);
  }
  for (std::uint32_t address = 0x00000180; address < 0x000001c0; address += 4) {
      cache->tryCacheUInt32(address);
  }
  cache->tryCacheUInt32(0x00000500);
  cache->tryCacheUInt32(0x00000504);
  for (std::uint32_t address = 0x00000540; address < 0x00000550; address += 4) {
      cache->tryCacheUInt32(address);
  }
  for (std::uint32_t address = 0x00000600; address < 0x00000640; address += 4) {
      cache->tryCacheUInt32(address);
  }
  for (std::uint32_t address = 0x00000800; address < 0x00001000; address += 4) {
      cache->tryCacheUInt32(address);
  }
  for (std::uint32_t address = 0x00008000; address < 0x00010000; address += 4) {
      cache->tryCacheUInt32(address);
  }
}

/**
 * Preheats the cache for a VME-EVM-300. This helps reduce the initialization
 * time of the IOC because preheating can happen for several devices in
 * parallel, while the record initialization itself is not parallelized and
 * would that have to wait for each I/O request to finish before it could
 * continue. There is no error checking here. If there is an error, the memory
 * location simply won't be cached, and the respective error will be presented
 * to the user when the second I/O attempt that is made after checking the cache
 * fails (unless the underlying problem has been resolved by then).
 */
void preheatCacheVmeEvm300(std::shared_ptr<MrfMemoryCache> cache) {
  // This code has been generated by preheat-cache-codegen.py using the output
  // of mrfDumpCache(...). If output records are added to the record file, this
  // code section needs to be updated.
  // TODO Paste generated code here.
}

/**
 * Preheats the cache for a VME-EVR-230RF. This helps reduce the initialization
 * time of the IOC because preheating can happen for several devices in
 * parallel, while the record initialization itself is not parallelized and
 * would that have to wait for each I/O request to finish before it could
 * continue. There is no error checking here. If there is an error, the memory
 * location simply won't be cached, and the respective error will be presented
 * to the user when the second I/O attempt that is made after checking the cache
 * fails (unless the underlying problem has been resolved by then).
 *
 * We use the same code for both the VME-EVR-230 and VME-EVR-230RF: The two
 * differ slightly in the registers for the outputs, but as this code is only
 * run for performance reasons and the differences are very small, treating
 * both types of devices as a VME-EVR-230RF here is okay.
 */
void preheatCacheVmeEvr230Rf(std::shared_ptr<MrfMemoryCache> cache) {
  // This code has been generated by preheat-cache-codegen.py using the output
  // of mrfDumpCache(...). If output records are added to the record file, this
  // code section needs to be updated.
  for (std::uint32_t address = 0x00000400; address < 0x0000040e; address += 2) {
      cache->tryCacheUInt16(address);
  }
  for (std::uint32_t address = 0x00000440; address < 0x00000448; address += 2) {
      cache->tryCacheUInt16(address);
  }
  for (std::uint32_t address = 0x00000480; address < 0x000004a0; address += 2) {
      cache->tryCacheUInt16(address);
  }
  cache->tryCacheUInt16(0x00000614);
  cache->tryCacheUInt16(0x00000616);
  cache->tryCacheUInt16(0x00000634);
  cache->tryCacheUInt16(0x00000636);
  cache->tryCacheUInt16(0x00000654);
  cache->tryCacheUInt16(0x00000656);
  cache->tryCacheUInt32(0x00000004);
  cache->tryCacheUInt32(0x0000000c);
  cache->tryCacheUInt32(0x00000010);
  cache->tryCacheUInt32(0x00000020);
  cache->tryCacheUInt32(0x00000024);
  cache->tryCacheUInt32(0x00000040);
  cache->tryCacheUInt32(0x0000004c);
  cache->tryCacheUInt32(0x00000080);
  for (std::uint32_t address = 0x00000100; address < 0x0000010c; address += 4) {
      cache->tryCacheUInt32(address);
  }
  for (std::uint32_t address = 0x00000200; address < 0x00000244; address += 4) {
      cache->tryCacheUInt32(address);
  }
  for (std::uint32_t address = 0x00000248; address < 0x00000254; address += 4) {
      cache->tryCacheUInt32(address);
  }
  for (std::uint32_t address = 0x00000258; address < 0x00000264; address += 4) {
      cache->tryCacheUInt32(address);
  }
  for (std::uint32_t address = 0x00000268; address < 0x00000274; address += 4) {
      cache->tryCacheUInt32(address);
  }
  for (std::uint32_t address = 0x00000278; address < 0x00000284; address += 4) {
      cache->tryCacheUInt32(address);
  }
  for (std::uint32_t address = 0x00000288; address < 0x00000294; address += 4) {
      cache->tryCacheUInt32(address);
  }
  for (std::uint32_t address = 0x00000298; address < 0x000002a4; address += 4) {
      cache->tryCacheUInt32(address);
  }
  for (std::uint32_t address = 0x000002a8; address < 0x000002b4; address += 4) {
      cache->tryCacheUInt32(address);
  }
  for (std::uint32_t address = 0x000002b8; address < 0x000002c4; address += 4) {
      cache->tryCacheUInt32(address);
  }
  for (std::uint32_t address = 0x000002c8; address < 0x000002d4; address += 4) {
      cache->tryCacheUInt32(address);
  }
  for (std::uint32_t address = 0x000002d8; address < 0x000002e4; address += 4) {
      cache->tryCacheUInt32(address);
  }
  for (std::uint32_t address = 0x000002e8; address < 0x000002f4; address += 4) {
      cache->tryCacheUInt32(address);
  }
  cache->tryCacheUInt32(0x000002f8);
  cache->tryCacheUInt32(0x000002fc);
  cache->tryCacheUInt32(0x00000500);
  cache->tryCacheUInt32(0x00000504);
  for (std::uint32_t address = 0x00000600; address < 0x00000614; address += 4) {
      cache->tryCacheUInt32(address);
  }
  cache->tryCacheUInt32(0x00000618);
  for (std::uint32_t address = 0x00000620; address < 0x00000634; address += 4) {
      cache->tryCacheUInt32(address);
  }
  cache->tryCacheUInt32(0x00000638);
  for (std::uint32_t address = 0x00000640; address < 0x00000654; address += 4) {
      cache->tryCacheUInt32(address);
  }
  cache->tryCacheUInt32(0x00000658);
  for (std::uint32_t address = 0x00001800; address < 0x00002000; address += 4) {
      cache->tryCacheUInt32(address);
  }
  for (std::uint32_t address = 0x00004000; address < 0x00006000; address += 4) {
      cache->tryCacheUInt32(address);
  }
  for (std::uint32_t address = 0x00020000; address < 0x00022000; address += 4) {
      cache->tryCacheUInt32(address);
  }
  for (std::uint32_t address = 0x00024000; address < 0x00026000; address += 4) {
      cache->tryCacheUInt32(address);
  }
  for (std::uint32_t address = 0x00028000; address < 0x0002a000; address += 4) {
      cache->tryCacheUInt32(address);
  }
}

/**
 * Preheats the cache for a VME-EVR-300. This helps reduce the initialization
 * time of the IOC because preheating can happen for several devices in
 * parallel, while the record initialization itself is not parallelized and
 * would that have to wait for each I/O request to finish before it could
 * continue. There is no error checking here. If there is an error, the memory
 * location simply won't be cached, and the respective error will be presented
 * to the user when the second I/O attempt that is made after checking the cache
 * fails (unless the underlying problem has been resolved by then).
 */
void preheatCacheVmeEvr300(std::shared_ptr<MrfMemoryCache> cache) {
  // This code has been generated by preheat-cache-codegen.py using the output
  // of mrfDumpCache(...). If output records are added to the record file, this
  // code section needs to be updated.
  // TODO Paste generated code here.
}

/**
 * Creates (and registers) a UDP/IP device. EVG and EVR devices are nearly
 * identical with the exception that they use a different base address.
 */
void createUdpIpDevice(
    const std::string& deviceId,
    const std::string &hostName,
    std::uint32_t baseAddress,
    const std::chrono::duration<double> queueTimeout,
    const std::chrono::duration<double> requestTimeout,
    std::function<void(std::shared_ptr<MrfMemoryCache>)> preheatFunction) {
  std::shared_ptr<MrfUdpIpMemoryAccess> rawDevice = std::make_shared<
    MrfUdpIpMemoryAccess>(hostName, baseAddress, queueTimeout, requestTimeout);
  std::shared_ptr<MrfConsistentAsynchronousMemoryAccess> consistentDevice =
      std::make_shared<MrfConsistentAsynchronousMemoryAccess>(rawDevice);
  MrfDeviceRegistry::getInstance().registerDevice(std::string(deviceId),
      consistentDevice);
  // We want to preheat the cache. We do not have to check whether the returned
  // pointer is null, because it won't be null if registerDevice did not throw
  // an exception.
  auto cache = MrfDeviceRegistry::getInstance().getDeviceCache(deviceId);
  std::thread preheatThread([cache, preheatFunction]() {
    preheatFunction(cache);
  });
  // We want to continue the preheating in the background, so we detach the
  // thread.
  preheatThread.detach();
}

/**
 * Common implementation of the iocsh mrfUdpIpVmeEvg230Device,
 * mrfUdpIpVmeEvm300Device, mrfUdpIpVmeEvr230Device, mrfUdpIpVmeEvr230RfDevice,
 * and mrfUdpIpVmeEvr300Device functions.
 */
int iocshMrfUdpIpDeviceFunc(
  const iocshArgBuf *args,
  std::uint32_t baseAddress,
  std::function<void(std::shared_ptr<MrfMemoryCache>)> preheatFunction)
  noexcept {
  char *deviceId = args[0].sval;
  char *hostAddress = args[1].sval;
  double queueTimeoutDouble = args[2].dval;
  double requestTimeoutDouble = args[3].dval;
  // Verify and convert the parameters.
  if (!deviceId) {
    errorPrintf("Could not create device: Device ID must be specified.");
    return 1;
  }
  if (!std::strlen(deviceId)) {
    errorPrintf("Could not create device: Device ID must not be empty.");
    return 1;
  }
  // Until here our code does not throw. We put the rest of the function into a
  // try-catch statement, so that we handle all other exceptions.
  try {
    if (!hostAddress) {
      throw std::invalid_argument("Host name or address must be specified.");
    }
    if (!std::strlen(hostAddress)) {
      throw std::invalid_argument("Host name or address must not be empty.");
    }
    if (!std::isfinite(queueTimeoutDouble)) {
      throw std::invalid_argument(
        "Queue timeout must be finite.");
    }
    if (queueTimeoutDouble < 0.0) {
      queueTimeoutDouble = 0.0;
    }
    if (!std::isfinite(requestTimeoutDouble) || requestTimeoutDouble < 0.0) {
      throw std::invalid_argument(
        "Request timeout must be finite.");
    }
    if (requestTimeoutDouble <= 0.0) {
      // We use a default value of 5 seconds. For any local network that is not
      // experiencing a tremendous amount of packet loss, this should be
      // sufficient.
      requestTimeoutDouble = 5.0;
    }
    auto queueTimeout = std::chrono::duration<double>(queueTimeoutDouble);
    auto requestTimeout = std::chrono::duration<double>(requestTimeoutDouble);
    createUdpIpDevice(
      deviceId,
      hostAddress,
      baseAddress,
      queueTimeout,
      requestTimeout,
      preheatFunction);
  } catch (std::exception &e) {
    anka::mrf::epics::errorPrintf("Could not create device %s: %s", deviceId,
        e.what());
    return 1;
  } catch (...) {
    anka::mrf::epics::errorPrintf("Could not create device %s: Unknown error.",
        deviceId);
    return 1;
  }
  return 0;
}

} // anonymous namespace

extern "C" {

// Data structures needed for the iocsh mrfUdpIpDevice function.
static const iocshArg iocshMrfUdpIpDeviceArg0 = {"device ID", iocshArgString};
static const iocshArg iocshMrfUdpIpDeviceArg1 = {
  "host name or address", iocshArgString
};
static const iocshArg iocshMrfUdpIpDeviceArg2 = {
  "queue timeout (seconds)", iocshArgDouble
};
static const iocshArg iocshMrfUdpIpDeviceArg3 = {
  "request timeout (seconds)", iocshArgDouble
};
static const iocshArg * const iocshMrfUdpIpDeviceArgs[] = {
  &iocshMrfUdpIpDeviceArg0,
  &iocshMrfUdpIpDeviceArg1,
  &iocshMrfUdpIpDeviceArg2,
  &iocshMrfUdpIpDeviceArg3
};
static const iocshFuncDef iocshMrfUdpIpEvgDeviceFuncDef = {
  "mrfUdpIpEvgDevice",
  4,
  iocshMrfUdpIpDeviceArgs,
#ifdef IOCSHFUNCDEF_HAS_USAGE
  "Define a UDP/IP connection to a VME-EVG-230 (deprecated, replace with "
  "mrfUdpIpVmeEvg230Device).\n",
#endif // IOCSHFUNCDEF_HAS_USAGE
};
static const iocshFuncDef iocshMrfUdpIpEvrDeviceFuncDef = {
  "mrfUdpIpEvrDevice",
  4,
  iocshMrfUdpIpDeviceArgs,
#ifdef IOCSHFUNCDEF_HAS_USAGE
  "Define a UDP/IP connection to a VME-EVR-230 or VME-EVR-230RF (deprecated, "
  "replace with mrfUdpIpVmeEvr230Device or mrfUdpIpVmeEvr230RfDevice).\n",
#endif // IOCSHFUNCDEF_HAS_USAGE
};
static const iocshFuncDef iocshMrfUdpIpVmeEvg230DeviceFuncDef = {
  "mrfUdpIpVmeEvg230Device",
  4,
  iocshMrfUdpIpDeviceArgs,
#ifdef IOCSHFUNCDEF_HAS_USAGE
  "Define a UDP/IP connection to a VME-EVG-230.\n",
#endif // IOCSHFUNCDEF_HAS_USAGE
};
static const iocshFuncDef iocshMrfUdpIpVmeEvm300DeviceFuncDef = {
  "mrfUdpIpVmeEvm300Device",
  4,
  iocshMrfUdpIpDeviceArgs,
#ifdef IOCSHFUNCDEF_HAS_USAGE
  "Define a UDP/IP connection to a VME-EVM-300.\n",
#endif // IOCSHFUNCDEF_HAS_USAGE
};
static const iocshFuncDef iocshMrfUdpIpVmeEvr230DeviceFuncDef = {
  "mrfUdpIpVmeEvr230Device",
  4,
  iocshMrfUdpIpDeviceArgs,
#ifdef IOCSHFUNCDEF_HAS_USAGE
  "Define a UDP/IP connection to a VME-EVR-230.\n",
#endif // IOCSHFUNCDEF_HAS_USAGE
};
static const iocshFuncDef iocshMrfUdpIpVmeEvr230RfDeviceFuncDef = {
  "mrfUdpIpVmeEvr230RfDevice",
  4,
  iocshMrfUdpIpDeviceArgs,
#ifdef IOCSHFUNCDEF_HAS_USAGE
  "Define a UDP/IP connection to a VME-EVR-230RF.\n",
#endif // IOCSHFUNCDEF_HAS_USAGE
};
static const iocshFuncDef iocshMrfUdpIpVmeEvr300DeviceFuncDef = {
  "mrfUdpIpVmeEvr300Device",
  4,
  iocshMrfUdpIpDeviceArgs,
#ifdef IOCSHFUNCDEF_HAS_USAGE
  "Define a UDP/IP connection to a VME-EVR-300.\n",
#endif // IOCSHFUNCDEF_HAS_USAGE
};

/**
 * Implementation of the iocsh mrfUdpIpVmeEvg230Device and mrfUdpIpEvgDevice
 * functions.
 */
static void iocshMrfUdpIpVmeEvg230DeviceFunc(
    const iocshArgBuf *args) noexcept {
  MRF_IOC_SET_ERROR(
    iocshMrfUdpIpDeviceFunc(
      args,
      MrfUdpIpMemoryAccess::baseAddressVmeEvgRegister,
      preheatCacheVmeEvg230));
}

/**
 * Implementation of the iocsh mrfUdpIpVmeEvm300Device function.
 */
static void iocshMrfUdpIpVmeEvm300DeviceFunc(
    const iocshArgBuf *args) noexcept {
  MRF_IOC_SET_ERROR(
    iocshMrfUdpIpDeviceFunc(
      args,
      MrfUdpIpMemoryAccess::baseAddressVmeEvmRegister,
      preheatCacheVmeEvm300));
}

/**
 * Implementation of the iocsh mrfUdpIpVmeEvr230Device.
 */
static void iocshMrfUdpIpVmeEvr230DeviceFunc(
    const iocshArgBuf *args) noexcept {
  MRF_IOC_SET_ERROR(
    iocshMrfUdpIpDeviceFunc(
      args,
      MrfUdpIpMemoryAccess::baseAddressVmeEvr230Register,
      preheatCacheVmeEvr230Rf));
}

/**
 * Implementation of the iocsh mrfUdpIpVmeEvr230RfDevice and mrfUdpIpEvrDevice
 * functions.
 */
static void iocshMrfUdpIpVmeEvr230RfDeviceFunc(
    const iocshArgBuf *args) noexcept {
  MRF_IOC_SET_ERROR(
    iocshMrfUdpIpDeviceFunc(
      args,
      MrfUdpIpMemoryAccess::baseAddressVmeEvr230Register,
      preheatCacheVmeEvr230Rf));
}

/**
 * Implementation of the iocsh mrfUdpIpVmeEvr300Device function.
 */
static void iocshMrfUdpIpVmeEvr300DeviceFunc(
    const iocshArgBuf *args) noexcept {
  MRF_IOC_SET_ERROR(
    iocshMrfUdpIpDeviceFunc(
      args,
      MrfUdpIpMemoryAccess::baseAddressVmeEvr300Register,
      preheatCacheVmeEvr300));
}

/*
 * Registrar that registers the iocsh commands.
 */
static void mrfRegistrarUdpIp() {
  // The mrfUdpIpEvgDevice function is the same as mrfUdpIpVmeEvg230Device, but
  // we also provide it under that name for backward compatibility.
  iocshRegister(
    &iocshMrfUdpIpEvgDeviceFuncDef, iocshMrfUdpIpVmeEvg230DeviceFunc);
  // The mrfUdpIpEvrDevice function is the same as mrfUdpIpVmeEvr230RfDevice,
  // but we also provide it under that name for backward compatibility.
  iocshRegister(
    &iocshMrfUdpIpEvrDeviceFuncDef, iocshMrfUdpIpVmeEvr230RfDeviceFunc);
  iocshRegister(
    &iocshMrfUdpIpVmeEvg230DeviceFuncDef, iocshMrfUdpIpVmeEvg230DeviceFunc);
  iocshRegister(
    &iocshMrfUdpIpVmeEvm300DeviceFuncDef, iocshMrfUdpIpVmeEvm300DeviceFunc);
  iocshRegister(
    &iocshMrfUdpIpVmeEvr230DeviceFuncDef, iocshMrfUdpIpVmeEvr230DeviceFunc);
  iocshRegister(
    &iocshMrfUdpIpVmeEvr230RfDeviceFuncDef,
    iocshMrfUdpIpVmeEvr230RfDeviceFunc);
  iocshRegister(
    &iocshMrfUdpIpVmeEvr300DeviceFuncDef, iocshMrfUdpIpVmeEvr300DeviceFunc);
}

epicsExportRegistrar(mrfRegistrarUdpIp);

}
